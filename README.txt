从纯色背景中抠出图片的主体
-------------------------------------------------------------------------------------------
Ver2.0&正式版
Ver1.0因为没有遍历所有像素，有死角，Ver1.1和1.5没有死角但速度极慢，没有实用性。
Ver2.0一方面使用numpy而非image遍历像素，另一方面对遍历的算法做了一点微小的工作，使得每秒处理的像素数量从几十个上升到几万个，可以实用了。
提示信息还是写了（真香）

————正式版使用手册
    把要抠的图片扔source文件夹，运行程序。
    开始了首先要指定抠图容差，当某个像素颜色和背景色之差小于容差时，这个像素就被判定为需要抠掉。
    程序会自动以最左上角像素的颜色为背景色，如果该像素为透明，会提示手动以rgb值指定背景色。
    程序会抠出纯色背景图片的主体部分，并将主体部分的背景调为透明。
        这个算法实现了边缘检测，但只能检测到算法认为的边缘，比如一条丝带围了一圈，在人看来中间一圈白的是要抠掉的，但是算法认不出来。
        这种可以抠掉外面的背景后手动用PS什么的点一个透明像素在里面，再跑一遍算法，上文中“若左上角像素为透明”针对的就是这种情况。
        还有一种情况就是比如一张纸，边缘是黑的，中间是白的，这张纸超出了图片的边界，在人看来是不应该抠掉的，但是算法就会把纸中间的白色像素抠掉。
        这种因为抠掉的都是纯色，可以用PS手动填充一下，应该不怎么麻烦。
        这两种边界检测的算法是想不出来了，目测要用机器学习弄，菜鸡表示......
    只支持PNG格式。


下一步在考虑搞多线程优化，让速度像香港记者一样。
-------------------------------------------------------------------------------------------
Ver1.5
得，广度优先也是复杂度爆炸，遍历像素的算法再大改一次，从每一行左到右遍历一次，遇到要抠掉的像素就抠掉，遇到不用抠掉的像素就跳到下一行，整张图遍历一遍之后再每一行从右到左，每一列从上到下，再从下到上一次。这个基本上就是Ver1.0里的算法，区别在于Ver1.0遇到不用抠掉的像素不会跳到下一行，而是继续把那一行遍历完，而根据判断像素是否需要被抠掉的算法，Ver1.0确实可以抠掉，但一个像素会重复访问多次造成复杂度爆炸。既然会四个方向都遍历一遍，就犯不着一个像素访问好几次了，改。
Ver1.5的算法还是会留下一些死角，比如一个触手绕了一圈，但是没有封闭，触手内部的像素是应该被抠掉的，但是算法照顾不到，这些死角交给广度优先，因为死角一般不会太多，广度优先的复杂度也可以接受。

-------------------------------------------------------------------------------------------
Ver1.1
乱写算法害死人，遍历像素的算法随手写的，复杂度爆炸还有死角，推倒重来，广度优先冲冲冲。

-------------------------------------------------------------------------------------------
Ver1.0

想把Deemo每首歌的封面抠出来，拆包后发现图片有255白的背景，而且尺寸也有1024*1024、2048*1024等等几种，主体周围都有一大圈255白。

先写了抠掉周围一圈白的算法，抠出透明背景的算法参考了https://2heng.xin/2018/04/05/python-pil/
可以抠出来，美滋滋。

但是现在的算法是只要是255白都给抠掉，很多希望留着的像素也给抠了，又加了个边缘检测的算法。

此处省略一万字Debug，Debug，Debug。

待处理的图片扔source，然后抠图.py，抠好的图就在done里了。

就是速度非常慢，抠一张1024*1024的图要十来秒......

关于算法的说明看注释吧，懒得写了。
写UI是不可能的，这辈子都不可能的，命令行都懒得写，反正把图片扔source，然后.py一下，就好了，可以手动设置的参数就一个抠图容差，手动在.py里改吧。

效果不错，美滋滋。

------------------------------------------------------------------------------------------

萌新第一次用Github，哪里不对劲求大佬指点。
